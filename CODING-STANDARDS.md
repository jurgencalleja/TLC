# TLC Coding Standards

> These standards apply to ALL code generated by TLC. Read before writing any code.

---

## 1. Project Structure: NestJS-Style Modules

### Standard Module Structure
```
src/modules/{entity}/
  ├── interfaces/                 # Types, DTOs, and interfaces
  │   ├── {entity}.interface.ts   # Main interface definitions
  │   └── index.ts                # Barrel export
  ├── dto/                        # Request/Response DTOs (if needed)
  │   ├── create.dto.ts
  │   ├── update.dto.ts
  │   └── index.ts
  ├── enums/                      # Enums and constants (if needed)
  │   ├── {feature}.enum.ts
  │   └── index.ts
  ├── constants/                  # Constants and magic values (if needed)
  │   ├── {feature}.constant.ts
  │   └── index.ts
  ├── guards/                     # Auth/permission guards (if needed)
  │   ├── {feature}.guard.ts
  │   └── index.ts
  ├── {entity}.service.ts         # Business logic
  ├── {entity}.controller.ts      # HTTP handlers (if applicable)
  ├── {entity}.routes.ts          # Route definitions (if applicable)
  ├── {entity}.repository.ts      # Data access (if applicable)
  ├── {entity}.seed.ts            # Seed data
  ├── {entity}.test.ts            # Tests
  └── index.ts                    # Public exports
```

### Shared Code
```
src/
  ├── lib/                        # Core libraries
  │   ├── config/                 # Environment-driven configuration
  │   └── configuration.ts        # Centralized config
  ├── shared/                     # Cross-cutting concerns
  │   ├── config/                 # Service-specific configs
  │   ├── utils/                  # Generic helpers
  │   ├── middleware/             # Framework middleware
  │   └── interfaces/             # Only truly shared types
```

### ❌ WALL OF SHAME - Never Do This

```
src/
  services/          # ❌ All services dumped together
  interfaces/        # ❌ All types dumped together
  controllers/       # ❌ All controllers dumped together
  seeds.ts           # ❌ One mega seed file

# Loose files at server root:
server/
  auth.ts            # ❌ Should be in modules/auth/
  email.ts           # ❌ Should be in modules/email/
  user-controller.ts # ❌ Should be in modules/user/
  helpers.ts         # ❌ Should be in lib/ or shared/utils/
  config.ts          # ❌ Should be in lib/config/
  types.ts           # ❌ Should be in relevant module's interfaces/

# Inside a module:
{entity}/
  {entity}.interface.ts   # ❌ Flat interface file at module root
                          # ✅ Should be: interfaces/{entity}.interface.ts
```

### Server Root Policy

The server root should ONLY contain:
- `index.ts` / `index.js` - Entry point
- `package.json` - Dependencies
- Config files (`.env`, `tsconfig.json`, etc.)
- `lib/` - Core shared libraries
- `modules/` - Feature modules
- `shared/` - Cross-cutting utilities

**All business logic, controllers, services, and types go in `modules/{entity}/`.**

**Key principles**:
1. Group by domain, not by file type
2. Use subdirectories for organization (`interfaces/`, `dto/`, `enums/`, `guards/`)
3. Every module has an `index.ts` barrel export
4. Interfaces NEVER live at module root - always in `interfaces/` subdirectory

---

## 2. Types & Interfaces: Always in Subdirectory

### ✅ Correct: Interfaces in subdirectory
```
{entity}/
  interfaces/
    index.ts                    # Re-exports everything
    {entity}.interface.ts       # Core entity types
    dto.interface.ts            # Request/response DTOs (optional)
```

```typescript
// {entity}/interfaces/{entity}.interface.ts
/**
 * Represents a user account in the system.
 */
export interface User {
  /** Unique identifier (UUID v4) */
  id: string;
  /** Email address (unique, lowercase) */
  email: string;
  /** Account creation timestamp */
  createdAt: Date;
}

/**
 * DTO for creating a new user.
 */
export interface CreateUserDTO {
  email: string;
  password: string;
}

// {entity}/interfaces/index.ts
export * from './{entity}.interface';
```

### ❌ NEVER: Interfaces at module root or inline
```typescript
// ❌ WRONG: {entity}/{entity}.interface.ts (at module root)
// ✅ CORRECT: {entity}/interfaces/{entity}.interface.ts

// ❌ WRONG: Inside service file
class UserService {
  interface User { ... }  // NEVER declare interfaces inside services
}
```

---

## 3. DTOs: Separate from Interfaces

For modules with many request/response types, use a `dto/` folder:

```
{entity}/
  dto/
    index.ts
    create.dto.ts
    update.dto.ts
    response.dto.ts
```

```typescript
// {entity}/dto/create.dto.ts
/**
 * DTO for user creation request.
 */
export interface CreateUserDto {
  /** User's email address */
  email: string;
  /** User's password (min 8 chars) */
  password: string;
  /** Optional display name */
  displayName?: string;
}
```

---

## 4. Guards: Authentication & Authorization Middleware

Place guards in a `guards/` subdirectory:

```
{entity}/
  guards/
    index.ts
    require-auth.guard.ts
    require-permission.guard.ts
```

```typescript
// {entity}/guards/require-auth.guard.ts
/**
 * Middleware that requires user authentication.
 */
export function requireAuth(req: Request, res: Response, next: NextFunction): void {
  if (!req.isAuthenticated()) {
    res.status(401).json({ error: 'Authentication required' });
    return;
  }
  next();
}
```

---

## 5. Enums & Constants: Organized by Feature

```
{entity}/
  enums/
    index.ts
    status.enum.ts
  constants/
    index.ts
    limits.constant.ts
```

```typescript
// {entity}/enums/status.enum.ts
/**
 * Possible statuses for an entity.
 */
export const ENTITY_STATUS = ['pending', 'active', 'completed', 'cancelled'] as const;
export type EntityStatus = (typeof ENTITY_STATUS)[number];

// {entity}/constants/limits.constant.ts
/**
 * Rate limits for API endpoints.
 */
export const RATE_LIMITS = {
  MAX_REQUESTS_PER_MINUTE: 100,
  MAX_BATCH_SIZE: 50,
} as const;
```

### ❌ NEVER: Magic strings in code
```typescript
// ❌ WRONG
if (status === 'pending') { ... }

// ✅ CORRECT
import { ENTITY_STATUS } from './enums';
if (status === 'pending') { ... }  // TypeScript will validate
```

---

## 6. Configuration: No Hardcoded Values

```typescript
// ❌ NEVER
class PaymentService {
  private baseUrl = "https://api.stripe.com";
  private timeout = 30000;
}

// ✅ ALWAYS
// lib/configuration.ts or shared/config/stripe.config.ts
export const stripeConfig = {
  baseUrl: process.env.STRIPE_BASE_URL || 'https://api.stripe.com',
  apiKey: process.env.STRIPE_API_KEY,
  timeout: parseInt(process.env.STRIPE_TIMEOUT || '30000'),
} as const;
```

**Rule**: If it could differ between environments, it's config.

---

## 7. Seeds: Per-Entity Files

```typescript
// ❌ NEVER: seeds.ts with everything
export async function seedAll() {
  await db.users.insert([...50 users...]);
  await db.projects.insert([...30 projects...]);
}

// ✅ ALWAYS: Per-entity seed files
// modules/users/user.seed.ts
export const userSeeds: User[] = [
  { id: 'user-1', email: 'admin@example.com', ... },
];

export async function seedUsers(db: Database): Promise<void> {
  await db.users.insertMany(userSeeds);
}
```

---

## 8. JSDoc: Document Everything Public

```typescript
/**
 * Manages user account operations.
 */
export class UserService {
  /**
   * Creates a new user account.
   * @param data - User registration payload
   * @returns Created user without password
   * @throws {ConflictError} Email already registered
   * @throws {ValidationError} Invalid email format
   */
  async create(data: CreateUserDTO): Promise<User> {
    // ...
  }
}
```

---

## 9. File Naming Convention

| Type | Pattern | Example |
|------|---------|---------|
| Interface file | `interfaces/{entity}.interface.ts` | `interfaces/user.interface.ts` |
| DTO file | `dto/{action}.dto.ts` | `dto/create.dto.ts` |
| Enum file | `enums/{feature}.enum.ts` | `enums/status.enum.ts` |
| Constant file | `constants/{feature}.constant.ts` | `constants/limits.constant.ts` |
| Guard file | `guards/{feature}.guard.ts` | `guards/require-auth.guard.ts` |
| Service | `{entity}.service.ts` | `user.service.ts` |
| Controller | `{entity}.controller.ts` | `user.controller.ts` |
| Routes | `{entity}.routes.ts` | `user.routes.ts` |
| Seeds | `{entity}.seed.ts` | `user.seed.ts` |
| Tests | `{entity}.test.ts` | `user.test.ts` |
| Index | `index.ts` | `index.ts` |

---

## 10. Module Index Exports

Every module's `index.ts` should export the public API:

```typescript
// modules/user/index.ts
/**
 * @fileoverview User module - User management.
 * @module user
 */

// Services
export { UserService, userService } from './user.service';

// Interfaces & Types
export * from './interfaces';

// DTOs (if separate folder)
export * from './dto';

// Guards (if applicable)
export * from './guards';
```

---

## 11. Import Rules

### Use Path Aliases
```typescript
// CORRECT: Path alias
import { User } from '@/modules/user/interfaces';

// AVOID: Deep relative paths
import { User } from '../../../modules/user/interfaces/user.interface';
```

### Import Order
1. Node built-ins (`fs`, `path`, `crypto`)
2. External packages (`express`, `zod`)
3. Internal modules using path aliases
4. Relative imports (same module only)

---

## 12. Error Handling

### Custom Error Classes
```typescript
// src/lib/errors/index.ts
export class AppError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 500
  ) {
    super(message);
    this.name = this.constructor.name;
  }
}

export class NotFoundError extends AppError {
  constructor(entity: string, id: string) {
    super(`${entity} not found: ${id}`, 'NOT_FOUND', 404);
  }
}
```

---

## 13. Deprecated Re-exports

When migrating, old file locations should become deprecated re-exports:

```typescript
// server/auth.ts (old location)
/**
 * @fileoverview Authentication module.
 * @deprecated This file is deprecated. Import from './modules/auth' instead.
 */
export {
  setupAuth,
  registerAuthRoutes,
  requireAuth,
} from './modules/auth';
```

---

## Quick Checklist

Before committing any code:

- [ ] **No loose files in server root** - only index.ts, package.json, and config
- [ ] All business logic in `modules/{entity}/` folders
- [ ] Interfaces in `interfaces/` subdirectory (never at module root)
- [ ] DTOs in `dto/` folder if module has many request/response types
- [ ] Enums/constants in dedicated folders (no magic strings)
- [ ] Guards in `guards/` folder
- [ ] No hardcoded URLs, keys, or environment values
- [ ] Seeds in per-entity `{entity}.seed.ts` files
- [ ] JSDoc on all public members
- [ ] Files organized by module with subdirectories
- [ ] Index files export public API
- [ ] Typed errors, not generic throws
- [ ] Tests co-located with module
- [ ] Build passes (`npm run build`)

---

---

## 14. Testing Standards

### Test Structure (Arrange-Act-Assert)
```typescript
it('should create user with valid input', async () => {
  // Arrange - setup test data and mocks
  const input = { email: 'test@example.com', name: 'Test' };
  mockRepository.create.mockResolvedValue({ id: '1', ...input });

  // Act - execute the code under test
  const result = await userService.create(input);

  // Assert - verify the outcome
  expect(result.id).toBe('1');
  expect(result.email).toBe('test@example.com');
});
```

### Test Naming
```typescript
// ✅ Good: Describes behavior
'should return null when user not found'
'should throw ValidationError for invalid email'
'should send welcome email after successful registration'

// ❌ Bad: Vague or implementation-focused
'test create'
'works correctly'
'calls repository'
```

### What to Test
- **Happy path**: Normal successful flow
- **Edge cases**: Empty input, null, boundaries
- **Error cases**: Invalid input, not found, permission denied
- **Integration points**: External APIs, database, file system

### What NOT to Test
- Framework code (Express routing, ORM queries)
- Third-party libraries
- Private implementation details
- Getters/setters without logic

---

## 15. Code Review Mindset

When writing code, imagine a reviewer asking:

1. **"What happens if this is null?"** - Handle it or document why it can't be.
2. **"What if this list is empty?"** - Handle the empty case.
3. **"What if this fails?"** - Proper error handling.
4. **"What if this is called twice?"** - Idempotency considerations.
5. **"What if input is malicious?"** - Security validation.
6. **"Will this scale to 1M records?"** - Performance implications.
7. **"Can I understand this in 6 months?"** - Clarity and documentation.

---

## 16. Function Design Patterns

### Guard Clauses (Early Return)
```typescript
// ❌ Bad: Deep nesting
async function processOrder(order: Order | null) {
  if (order) {
    if (order.items.length > 0) {
      if (order.status === 'pending') {
        // actual logic buried 3 levels deep
      }
    }
  }
}

// ✅ Good: Guard clauses
async function processOrder(order: Order | null) {
  if (!order) return;
  if (order.items.length === 0) return;
  if (order.status !== 'pending') return;

  // actual logic at top level, clear and readable
}
```

### Options Object for Many Parameters
```typescript
// ❌ Bad: Too many positional parameters
function sendEmail(to, subject, body, cc, bcc, replyTo, attachments, priority) {}

// ✅ Good: Options object
interface SendEmailOptions {
  to: string;
  subject: string;
  body: string;
  cc?: string[];
  bcc?: string[];
  replyTo?: string;
  attachments?: Attachment[];
  priority?: 'high' | 'normal' | 'low';
}

function sendEmail(options: SendEmailOptions) {}
```

### No Boolean Parameters
```typescript
// ❌ Bad: What does `true` mean?
processUser(user, true, false);

// ✅ Good: Explicit options
processUser(user, { sendWelcomeEmail: true, skipValidation: false });

// ✅ Better: Separate functions
processUserWithWelcomeEmail(user);
processUserSilently(user);
```

---

## 17. Commit Message Standards

```
type(scope): short description

- Detail 1
- Detail 2

Refs: #123
```

**Types:**
- `feat`: New feature
- `fix`: Bug fix
- `refactor`: Code restructure (no behavior change)
- `test`: Adding/updating tests
- `docs`: Documentation only
- `chore`: Build, config, dependencies

**Examples:**
```
feat(user): add password reset flow

- Add forgot password endpoint
- Send reset email via SendGrid
- Token expires in 1 hour

Refs: #456
```

---

## 18. File Size Limits

Large files are a code smell. They indicate a class or module is doing too much.

| Threshold | Action |
|---|---|
| **< 300 lines** | Ideal. No action needed. |
| **300-500 lines** | Acceptable. Review if it can be split. |
| **500-1000 lines** | Warning. Should be split into focused sub-modules. |
| **> 1000 lines** | Violation. MUST be split before merging. |

### How to Split

**Controllers with many routes:**
```
# Bad: csp.controller.ts (2,000+ lines)
# Good: Split by resource/feature:
modules/csp/
  controllers/
    policy.controller.ts      # CRUD for policies
    report.controller.ts      # CSP violation reports
    directive.controller.ts   # Directive management
  csp.routes.ts               # Route registration (thin)
```

**Services with many methods:**
```
# Bad: user.service.ts (1,500 lines)
# Good: Split by responsibility:
modules/user/
  services/
    user-auth.service.ts      # Login, register, password reset
    user-profile.service.ts   # Profile CRUD, avatar, preferences
    user-admin.service.ts     # Admin operations, ban, role changes
  user.service.ts             # Thin facade re-exporting sub-services
```

---

## 19. Folder Overcrowding

Too many files in one folder makes navigation difficult. Organize into subfolders by domain.

| Threshold | Action |
|---|---|
| **< 8 files** | Fine as-is. |
| **8-15 files** | Consider grouping into subfolders. |
| **> 15 files** | MUST be organized into subfolders. |

```
# Bad: 25 files dumped in controllers/
controllers/
  auth.controller.ts
  user.controller.ts
  payment.controller.ts
  invoice.controller.ts
  product.controller.ts
  ... (20 more)

# Good: Organized by domain
modules/
  auth/auth.controller.ts
  user/user.controller.ts
  billing/
    payment.controller.ts
    invoice.controller.ts
  catalog/
    product.controller.ts
```

---

## 20. Strict Typing

TypeScript without strict types is just JavaScript with extra steps.

### Rules

1. **No `any` type** - Use `unknown` and narrow, or define a proper interface.
2. **No implicit `any`** - Enable `noImplicitAny` in tsconfig.
3. **All functions must have explicit return types** - Not just exported functions.
4. **All parameters must be typed** - No untyped function parameters.
5. **Prefer `interface` over `type`** for object shapes - Easier to extend.
6. **Use `strict: true`** in tsconfig.json.

```typescript
// Bad: Missing types, implicit any
function processData(data) {
  const result = data.items.map(item => item.value);
  return result;
}

// Good: Explicit types everywhere
interface DataPayload {
  items: Array<{ value: number }>;
}

function processData(data: DataPayload): number[] {
  return data.items.map((item) => item.value);
}
```

```typescript
// Bad: any type
function handleResponse(response: any): any {
  return response.data;
}

// Good: Proper types
interface ApiResponse<T> {
  data: T;
  status: number;
}

function handleResponse<T>(response: ApiResponse<T>): T {
  return response.data;
}
```

### tsconfig.json Requirements

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true
  }
}
```

---

## AI Instructions

When generating code:

1. **Check** existing module structure first
2. **Create** module folder with proper subdirectories if entity doesn't exist
3. **Never** create loose files in server root - use `modules/`, `lib/`, or `shared/`
4. **Always use** `interfaces/` subdirectory for types
5. **Use** `dto/`, `enums/`, `guards/` subdirectories as needed
6. **Never** put interface files at module root
7. **Never** inline interfaces/types in service files
8. **Never** use magic strings - create enums/constants
9. **Never** hardcode configuration
10. **Never** add to monolithic seed files
11. **Always** add JSDoc to public members
12. **Always** create index.ts with barrel exports
13. **Always** verify build passes after changes
14. **Never** let files exceed 1000 lines - split into sub-modules
15. **Never** let folders exceed 15 files - organize into subfolders
16. **Never** use `any` type - use `unknown` or proper interfaces
17. **Always** add explicit return types to functions

### Cleanup Tasks

When cleaning up an existing codebase:

1. **Move loose files** from server root to proper modules
2. **Create deprecated re-exports** at old locations for backward compatibility
3. **Update imports** across the codebase
4. **Remove empty folders** after migration
5. **Commit after each module migration** (not all at once)
