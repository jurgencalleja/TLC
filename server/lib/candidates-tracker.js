/**
 * Candidates Tracker
 * Maintain REFACTOR-CANDIDATES.md automatically
 */

const fs = require('fs');
const path = require('path');

class CandidatesTracker {
  constructor(options = {}) {
    this.filePath = options.filePath || '.planning/REFACTOR-CANDIDATES.md';
    this.readFile = options.readFile || fs.promises.readFile;
    this.writeFile = options.writeFile || fs.promises.writeFile;
    this.mkdir = options.mkdir || fs.promises.mkdir;
  }

  /**
   * Load existing candidates from file
   */
  async load() {
    try {
      const content = await this.readFile(this.filePath, 'utf-8');
      return this.parse(content);
    } catch {
      return { high: [], medium: [], low: [], notes: '' };
    }
  }

  /**
   * Parse markdown content into structured data
   */
  parse(content) {
    const result = { high: [], medium: [], low: [], notes: '' };
    let currentSection = null;
    let notesStart = -1;

    const lines = content.split('\n');

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      if (line.includes('High Priority') || line.includes('Impact 80+')) {
        currentSection = 'high';
      } else if (line.includes('Medium Priority') || line.includes('Impact 50-79')) {
        currentSection = 'medium';
      } else if (line.includes('Low Priority') || line.includes('Impact <50')) {
        currentSection = 'low';
      } else if (line.includes('## Notes') || line.includes('## Manual Notes')) {
        notesStart = i;
        break;
      } else if (currentSection && line.startsWith('- [')) {
        const candidate = this.parseLine(line);
        if (candidate) {
          result[currentSection].push(candidate);
        }
      }
    }

    // Preserve notes section
    if (notesStart >= 0) {
      result.notes = lines.slice(notesStart).join('\n');
    }

    return result;
  }

  /**
   * Parse a single candidate line
   */
  parseLine(line) {
    // Format: - [x] file.js:10-20 - Description (Impact: 85)
    const match = line.match(/- \[([ x])\] (.+?):(\d+)(?:-(\d+))? - (.+?) \(Impact: (\d+)\)/);
    if (!match) return null;

    return {
      completed: match[1] === 'x',
      file: match[2],
      startLine: parseInt(match[3], 10),
      endLine: match[4] ? parseInt(match[4], 10) : parseInt(match[3], 10),
      description: match[5],
      impact: parseInt(match[6], 10),
      key: `${match[2]}:${match[3]}`,
    };
  }

  /**
   * Add candidates from analysis
   */
  async add(candidates) {
    const existing = await this.load();

    for (const candidate of candidates) {
      const tier = this.getTier(candidate.impact);
      const key = `${candidate.file}:${candidate.startLine}`;

      // Check for duplicate
      const existingIndex = existing[tier].findIndex(c => c.key === key);

      if (existingIndex >= 0) {
        // Update impact score
        existing[tier][existingIndex].impact = candidate.impact;
        existing[tier][existingIndex].description = candidate.description;
      } else {
        // Add new
        existing[tier].push({
          ...candidate,
          key,
          completed: false,
        });
      }
    }

    // Re-sort by impact
    for (const tier of ['high', 'medium', 'low']) {
      existing[tier].sort((a, b) => b.impact - a.impact);
    }

    await this.save(existing);
    return existing;
  }

  /**
   * Mark a candidate as complete
   */
  async markComplete(file, line) {
    const existing = await this.load();
    const key = `${file}:${line}`;

    for (const tier of ['high', 'medium', 'low']) {
      const candidate = existing[tier].find(c => c.key === key);
      if (candidate) {
        candidate.completed = true;
        break;
      }
    }

    await this.save(existing);
  }

  /**
   * Get priority tier from impact score
   */
  getTier(impact) {
    if (impact >= 80) return 'high';
    if (impact >= 50) return 'medium';
    return 'low';
  }

  /**
   * Save candidates to file
   */
  async save(data) {
    const content = this.format(data);

    // Ensure directory exists
    const dir = path.dirname(this.filePath);
    await this.mkdir(dir, { recursive: true });

    await this.writeFile(this.filePath, content);
  }

  /**
   * Format data as markdown
   */
  format(data) {
    let md = '# Refactor Candidates\n\n';
    md += '_Auto-generated by TLC. Run `/tlc:refactor` to process._\n\n';

    md += '## High Priority (Impact 80+)\n\n';
    for (const c of data.high) {
      md += this.formatCandidate(c);
    }
    if (data.high.length === 0) md += '_None_\n';
    md += '\n';

    md += '## Medium Priority (Impact 50-79)\n\n';
    for (const c of data.medium) {
      md += this.formatCandidate(c);
    }
    if (data.medium.length === 0) md += '_None_\n';
    md += '\n';

    md += '## Low Priority (Impact <50)\n\n';
    for (const c of data.low) {
      md += this.formatCandidate(c);
    }
    if (data.low.length === 0) md += '_None_\n';
    md += '\n';

    // Preserve notes
    if (data.notes) {
      md += data.notes;
    }

    return md;
  }

  /**
   * Format a single candidate as markdown line
   */
  formatCandidate(c) {
    const checkbox = c.completed ? 'x' : ' ';
    const lineRange = c.endLine && c.endLine !== c.startLine
      ? `${c.startLine}-${c.endLine}`
      : `${c.startLine}`;
    return `- [${checkbox}] ${c.file}:${lineRange} - ${c.description} (Impact: ${c.impact})\n`;
  }
}

module.exports = { CandidatesTracker };
