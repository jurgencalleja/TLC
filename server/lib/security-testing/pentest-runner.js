/**
 * Pentest Runner - Nuclei penetration testing
 */

// Common SQL injection payloads
const SQL_PAYLOADS = [
  "' OR '1'='1",
  "1; DROP TABLE users--",
  "' UNION SELECT * FROM users--",
  "1' AND '1'='1"
];

// Common XSS payloads
const XSS_PAYLOADS = [
  '<script>alert(1)</script>',
  '<img src=x onerror=alert(1)>',
  '"><script>alert(1)</script>',
  "javascript:alert(1)"
];

/**
 * Run Nuclei scan
 * @param {Object} options - Scan options
 * @param {string} options.target - Target URL
 * @param {Array} options.templates - Template categories to use
 * @param {Function} options.exec - Exec function for running commands
 * @returns {Promise<Array>} Scan findings
 */
export async function runNuclei({ target, templates = [], exec }) {
  let command = `nuclei -u ${target} -json`;

  if (templates.length > 0) {
    command += ` -t ${templates.join(',')}`;
  }

  const { stdout } = await exec(command);
  return JSON.parse(stdout);
}

/**
 * Test for SQL injection vulnerabilities
 * @param {Object} options - Test options
 * @param {string} options.url - URL to test
 * @param {Function} options.mockFetch - Mock fetch function for testing
 * @returns {Promise<Object>} Test result
 */
export async function testSqlInjection({ url, mockFetch }) {
  const fetchFn = mockFetch || fetch;

  for (const payload of SQL_PAYLOADS) {
    try {
      const testUrl = `${url}?id=${encodeURIComponent(payload)}`;
      const response = await fetchFn(testUrl);
      const text = await response.text();

      // Check for SQL error messages indicating vulnerability
      const errorPatterns = [
        'error in your SQL syntax',
        'mysql_fetch',
        'ORA-',
        'SQLServer',
        'sqlite3',
        'PostgreSQL',
        'SQLSTATE'
      ];

      if (errorPatterns.some(pattern => text.toLowerCase().includes(pattern.toLowerCase()))) {
        return {
          vulnerable: true,
          payload,
          evidence: text.substring(0, 200)
        };
      }
    } catch (e) {
      // Continue testing
    }
  }

  return { vulnerable: false };
}

/**
 * Test for XSS vulnerabilities
 * @param {Object} options - Test options
 * @param {string} options.url - URL to test
 * @param {Function} options.mockFetch - Mock fetch function for testing
 * @returns {Promise<Object>} Test result
 */
export async function testXss({ url, mockFetch }) {
  const fetchFn = mockFetch || fetch;

  for (const payload of XSS_PAYLOADS) {
    try {
      const testUrl = `${url}?q=${encodeURIComponent(payload)}`;
      const response = await fetchFn(testUrl);
      const text = await response.text();

      // Check if payload is reflected without encoding
      if (text.includes(payload)) {
        return {
          vulnerable: true,
          payload,
          evidence: text.substring(0, 200)
        };
      }
    } catch (e) {
      // Continue testing
    }
  }

  return { vulnerable: false };
}

/**
 * Test for authentication bypass
 * @param {Object} options - Test options
 * @param {string} options.url - Protected URL to test
 * @param {Function} options.mockFetch - Mock fetch function for testing
 * @returns {Promise<Object>} Test result
 */
export async function testAuthBypass({ url, mockFetch }) {
  const fetchFn = mockFetch || fetch;

  try {
    // Test accessing protected resource without authentication
    const response = await fetchFn(url, {
      headers: {
        // No auth headers
      }
    });

    // If we get a 200 on a protected endpoint, it's likely vulnerable
    if (response.status === 200) {
      return {
        vulnerable: true,
        evidence: 'Protected endpoint accessible without authentication'
      };
    }
  } catch (e) {
    // Network error, not a vulnerability indicator
  }

  return { vulnerable: false };
}

/**
 * Generate penetration test report
 * @param {Array} findings - List of findings
 * @returns {string} Formatted report
 */
export function generatePentestReport(findings) {
  if (findings.length === 0) {
    return '# Penetration Test Report\n\nNo vulnerabilities found.';
  }

  let report = '# Penetration Test Report\n\n';
  report += `Found ${findings.length} vulnerability(ies):\n\n`;

  const typeLabels = {
    sqli: 'SQL Injection',
    xss: 'Cross-Site Scripting (XSS)',
    auth_bypass: 'Authentication Bypass',
    default: 'Security Issue'
  };

  for (const finding of findings) {
    const label = typeLabels[finding.type] || typeLabels.default;
    report += `## ${label}\n`;
    report += `- **Severity:** ${finding.severity}\n`;
    report += `- **URL:** ${finding.url}\n`;
    if (finding.payload) {
      report += `- **Payload:** ${finding.payload}\n`;
    }
    if (finding.evidence) {
      report += `- **Evidence:** ${finding.evidence}\n`;
    }
    report += '\n';
  }

  return report;
}

/**
 * Create a pentest runner instance
 * @param {Object} options - Runner options
 * @returns {Object} Pentest runner instance
 */
export function createPentestRunner(options = {}) {
  return {
    /**
     * Run full scan with Nuclei
     * @param {Object} scanOptions - Scan options
     * @returns {Promise<Array>} Scan findings
     */
    async scan(scanOptions) {
      const { target, templates, exec } = scanOptions;
      if (exec) {
        return await runNuclei({ target, templates, exec });
      }
      return [];
    },

    /**
     * Test for SQL injection
     * @param {Object} testOptions - Test options
     * @returns {Promise<Object>} Test result
     */
    async testSqli(testOptions) {
      return await testSqlInjection(testOptions);
    },

    /**
     * Test for XSS
     * @param {Object} testOptions - Test options
     * @returns {Promise<Object>} Test result
     */
    async testXss(testOptions) {
      return await testXss(testOptions);
    },

    /**
     * Test for auth bypass
     * @param {Object} testOptions - Test options
     * @returns {Promise<Object>} Test result
     */
    async testAuthBypass(testOptions) {
      return await testAuthBypass(testOptions);
    }
  };
}
